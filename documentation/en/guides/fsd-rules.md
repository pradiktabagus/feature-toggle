# üìè FSD Development Rules & Guidelines

This document outlines the strict rules and best practices for developing features using Feature-Sliced Design (FSD) architecture.

## üö® Mandatory Rules

### 1. **Layer Dependency Rules**

#### ‚úÖ Allowed Dependencies
```
App Layer ‚Üí Widgets ‚Üí Features ‚Üí Entities ‚Üí Shared
```

#### ‚ùå Forbidden Dependencies
- **Shared** cannot import from any other layer
- **Entities** cannot import from Features, Widgets, or App
- **Features** cannot import from Widgets or App
- **Widgets** cannot import from App
- **No circular dependencies** between any layers

#### üîç Validation
```typescript
// ‚úÖ Correct imports
// In features/toggle/
import { Button } from '@/shared/components/ui/button'        // ‚úÖ Shared
import { useToggle } from '@/entities/toggle'                // ‚úÖ Entity

// ‚ùå Wrong imports  
// In entities/toggle/
import { ToggleForm } from '@/features/toggle/ui/toggle-form' // ‚ùå Feature
import { ToggleWidget } from '@/widgets/toggle'              // ‚ùå Widget
```

### 2. **File Naming Conventions**

#### Entity Files
```
entities/[entity-name]/
‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îú‚îÄ‚îÄ [entity-name].ts           # Types and interfaces
‚îÇ   ‚îú‚îÄ‚îÄ use-[entity-name].ts       # Main entity hook
‚îÇ   ‚îî‚îÄ‚îÄ [entity-name]-store.ts     # State management (if needed)
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ [entity-name]-api.ts       # API calls
‚îÇ   ‚îî‚îÄ‚îÄ [entity-name]-contracts.ts # API contracts
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îî‚îÄ‚îÄ [entity-name]-helpers.ts   # Pure functions
‚îî‚îÄ‚îÄ index.ts                       # Public exports
```

#### Feature Files
```
features/[feature-name]/
‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îú‚îÄ‚îÄ use-[feature-name].ts      # Business logic hooks
‚îÇ   ‚îú‚îÄ‚îÄ schemas.ts                 # Validation schemas
‚îÇ   ‚îî‚îÄ‚îÄ types.ts                   # Feature-specific types
‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îú‚îÄ‚îÄ [feature-name]-form.tsx    # Form components
‚îÇ   ‚îú‚îÄ‚îÄ [feature-name]-table.tsx   # Table components
‚îÇ   ‚îî‚îÄ‚îÄ [feature-name]-modal.tsx   # Modal components
‚îî‚îÄ‚îÄ index.ts                       # Feature exports
```

#### Widget Files
```
widgets/[widget-name]/
‚îú‚îÄ‚îÄ [widget-name]-widget.tsx       # Main widget component
‚îú‚îÄ‚îÄ components/                    # Widget-specific components
‚îÇ   ‚îú‚îÄ‚îÄ [component-name].tsx
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ index.ts                       # Widget exports
```

### 3. **Import/Export Rules**

#### Entity Exports
```typescript
// ‚úÖ Correct entity index.ts
export type { Toggle, CreateToggleRequest } from './model/toggle'
export { useToggle, useToggleActions } from './model/use-toggle'
export { toggleApi } from './api/toggle-api'
export * from './lib/toggle-helpers'

// ‚ùå Don't export internal implementation details
export { ToggleStore } from './model/toggle-store' // ‚ùå Internal
```

#### Feature Exports
```typescript
// ‚úÖ Correct feature index.ts
export { useToggleManagement } from './model/use-toggle-management'
export { toggleSchema } from './model/schemas'
export { ToggleForm, ToggleTable } from './ui'

// ‚ùå Don't export everything
export * from './model' // ‚ùå Too broad
export * from './ui'    // ‚ùå Too broad
```

### 4. **Business Logic Placement**

#### ‚úÖ Correct Placement
```typescript
// Business logic in entities/[entity]/model/
export function useToggle() {
  const [toggles, setToggles] = useState([])
  
  const createToggle = async (data) => {
    // Core business logic here ‚úÖ
  }
  
  return { toggles, createToggle }
}

// Feature-specific logic in features/[feature]/model/
export function useToggleManagement() {
  const { createToggle } = useToggle()
  
  const handleFormSubmit = (data) => {
    // Feature-specific orchestration ‚úÖ
    return createToggle(data)
  }
  
  return { handleFormSubmit }
}
```

#### ‚ùå Wrong Placement
```typescript
// ‚ùå Don't put business logic in UI components
export function ToggleForm() {
  const handleSubmit = async (data) => {
    // Complex business logic here ‚ùå
    const response = await fetch('/api/toggles', {
      method: 'POST',
      body: JSON.stringify(data)
    })
    // More business logic ‚ùå
  }
}
```

## üìã Best Practices

### 1. **Entity Development**

#### Single Responsibility
```typescript
// ‚úÖ Good: Each entity handles one domain
entities/toggle/     # Only toggle-related logic
entities/user/       # Only user-related logic
entities/cache/      # Only cache-related logic

// ‚ùå Bad: Mixed responsibilities
entities/toggle-user/ # ‚ùå Handles multiple domains
```

#### Pure Functions in Lib
```typescript
// entities/toggle/lib/toggle-helpers.ts
// ‚úÖ Pure functions only
export function formatToggleValue(value: unknown, type: string): string {
  // No side effects, predictable output
}

// ‚ùå Don't put side effects in lib
export function saveToggleToDatabase(toggle: Toggle) { // ‚ùå
  // Side effects belong in model layer
}
```

### 2. **Feature Development**

#### Feature Composition
```typescript
// ‚úÖ Compose features from entities
export function useToggleManagement() {
  const { toggles } = useToggle()           // Entity
  const { user } = useCurrentUser()        // Entity
  const { syncCache } = useCache()         // Entity
  
  // Feature orchestration logic
  const createToggleWithCache = async (data) => {
    const toggle = await createToggle(data)
    await syncCache(toggle.key)
    return toggle
  }
  
  return { createToggleWithCache }
}
```

#### UI Component Structure
```typescript
// ‚úÖ Clean UI components
export function ToggleForm() {
  const { handleSubmit } = useToggleManagement() // Business logic from model
  const form = useForm()                         // UI logic
  
  return (
    <form onSubmit={form.handleSubmit(handleSubmit)}>
      {/* UI only */}
    </form>
  )
}
```

### 3. **API Integration**

#### Entity API Layer
```typescript
// entities/toggle/api/toggle-api.ts
// ‚úÖ Entity-specific API calls
export const toggleApi = {
  getAll: () => api.get('/api/toggles'),
  create: (data: CreateToggleRequest) => api.post('/api/toggles', data),
  update: (id: string, data: UpdateToggleRequest) => 
    api.put(`/api/toggles/${id}`, data)
}

// ‚ùå Don't mix different entities
export const mixedApi = {
  getToggles: () => api.get('/api/toggles'),
  getUsers: () => api.get('/api/users'),     // ‚ùå Different entity
  getAnalytics: () => api.get('/api/analytics') // ‚ùå Different entity
}
```

#### Error Handling
```typescript
// ‚úÖ Consistent error handling
export function useToggle() {
  const [error, setError] = useState<string | null>(null)
  
  const createToggle = async (data) => {
    try {
      setError(null)
      return await toggleApi.create(data)
    } catch (err) {
      setError(err.message)
      throw err
    }
  }
  
  return { createToggle, error }
}
```

## üîß Code Quality Rules

### 1. **TypeScript Requirements**

#### Strict Typing
```typescript
// ‚úÖ Proper typing
interface Toggle {
  id: string
  name: string
  value: unknown  // Use unknown for dynamic values
  type: 'BOOLEAN' | 'STRING' | 'NUMBER' | 'JSON'
}

// ‚ùå Avoid any
interface Toggle {
  id: string
  name: string
  value: any      // ‚ùå Use unknown instead
}
```

#### Generic Types
```typescript
// ‚úÖ Use generics for reusable types
interface ApiResponse<T> {
  success: boolean
  data?: T
  error?: string
}

// Usage
const response: ApiResponse<Toggle[]> = await toggleApi.getAll()
```

### 2. **Performance Rules**

#### Memoization
```typescript
// ‚úÖ Memoize expensive computations
export function useToggleStats() {
  const { toggles } = useToggle()
  
  const stats = useMemo(() => {
    return calculateToggleStats(toggles) // Expensive calculation
  }, [toggles])
  
  return { stats }
}
```

#### Lazy Loading
```typescript
// ‚úÖ Lazy load heavy components
const ToggleAnalytics = lazy(() => import('./toggle-analytics'))

export function ToggleWidget() {
  return (
    <Suspense fallback={<Loading />}>
      <ToggleAnalytics />
    </Suspense>
  )
}
```

### 3. **Testing Rules**

#### Test Structure
```typescript
// entities/toggle/__tests__/use-toggle.test.ts
describe('useToggle', () => {
  describe('createToggle', () => {
    it('should create toggle successfully', () => {
      // Test implementation
    })
    
    it('should handle validation errors', () => {
      // Test error cases
    })
  })
})
```

#### Mock External Dependencies
```typescript
// ‚úÖ Mock external dependencies
jest.mock('@/shared/lib/prisma', () => ({
  prisma: {
    toggle: {
      create: jest.fn(),
      findMany: jest.fn()
    }
  }
}))
```

## üö´ Anti-Patterns

### 1. **God Components**
```typescript
// ‚ùå Don't create components that do everything
export function ToggleEverything() {
  // Handles forms ‚ùå
  // Handles tables ‚ùå  
  // Handles modals ‚ùå
  // Handles API calls ‚ùå
  // 500+ lines of code ‚ùå
}

// ‚úÖ Split into focused components
export function ToggleForm() { /* Form only */ }
export function ToggleTable() { /* Table only */ }
export function ToggleModal() { /* Modal only */ }
```

### 2. **Prop Drilling**
```typescript
// ‚ùå Don't pass props through many levels
<ToggleWidget>
  <ToggleList toggles={toggles}>
    <ToggleItem toggle={toggle} onUpdate={onUpdate}>
      <ToggleActions onUpdate={onUpdate} /> {/* ‚ùå Prop drilling */}
    </ToggleItem>
  </ToggleList>
</ToggleWidget>

// ‚úÖ Use context or state management
const ToggleContext = createContext()

<ToggleProvider>
  <ToggleWidget>
    <ToggleList>
      <ToggleItem>
        <ToggleActions /> {/* ‚úÖ Gets data from context */}
      </ToggleItem>
    </ToggleList>
  </ToggleWidget>
</ToggleProvider>
```

### 3. **Mixed Concerns**
```typescript
// ‚ùå Don't mix UI and business logic
export function ToggleForm() {
  const [toggles, setToggles] = useState([])
  
  // Business logic mixed with UI ‚ùå
  const handleSubmit = async (data) => {
    const response = await fetch('/api/toggles', {
      method: 'POST',
      body: JSON.stringify(data)
    })
    const newToggle = await response.json()
    setToggles(prev => [...prev, newToggle])
  }
  
  return <form onSubmit={handleSubmit}>...</form>
}

// ‚úÖ Separate concerns
export function ToggleForm() {
  const { handleSubmit } = useToggleManagement() // Business logic
  
  return <form onSubmit={handleSubmit}>...</form> // UI only
}
```

## üìä Validation Checklist

Before submitting code, ensure:

### Architecture Compliance
- [ ] No forbidden layer dependencies
- [ ] Proper file naming conventions
- [ ] Correct import/export patterns
- [ ] Business logic in appropriate layers

### Code Quality
- [ ] TypeScript strict mode compliance
- [ ] No `any` types (use `unknown` instead)
- [ ] Proper error handling
- [ ] Performance optimizations applied

### Testing
- [ ] Unit tests for business logic
- [ ] Component tests for UI
- [ ] Integration tests for API
- [ ] Mocked external dependencies

### Documentation
- [ ] JSDoc comments for public APIs
- [ ] README updated if needed
- [ ] Architecture documentation updated

## üõ†Ô∏è Tools & Automation

### ESLint Rules
```json
// .eslintrc.json
{
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "import/no-cycle": "error",
    "boundaries/element-types": "error"
  }
}
```

### Pre-commit Hooks
```bash
# Validate FSD structure before commit
npm run validate-fsd
npm run lint
npm run type-check
npm run test
```

## üìö Resources

- [FSD Official Documentation](https://feature-sliced.design/)
- [Adding New Features Guide](./adding-features.md)
- [Project Structure](../architecture/project-structure.md)
- [API Guidelines](../api/overview.md)